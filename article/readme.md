
Originally formulated in 1965 by Edsger Dijkstra 

# Задача
# Через разделяемое место
## Блокированные философов
## Голод философов
## Смерть философа
## Решения в User Space
## Решение через блокировку сразу всех
## Решение через блокировку только соседей
## Решения в Kernel Space
-- Semaphor (named / unnamed)
-- Mutex
## Гибридные решения
-- SemaphorSlim
-- Monitor (`lock`). TODO: deadlock here, and Monitor.TryLock(timeout)
--- Condition Variable Pattern
-- SpinLock 
-- ReaderWriterLockSlim. How? Ones computes, others checks results.
-- Barrier. Make all philosophers stop at %100 or smth.
### Transactional Memory (see art of multiproc. programming)
- https://github.com/jbakic/Shielded
- https://en.wikipedia.org/wiki/Software_transactional_memory#C#

# Через сообщения 
-- Agents and actors. Mention only? - actors model (Orleans and Akka.Net)
-- BlockingCollection<T> (producer / consumer) and thread local storage

# ? Comparing all solutions  


=======================================

# Сытые философы спустя 54 года или введение в конкурентное программирование на .Net 

В этой статье описываются способы распараллеливания в .Net на примере проблемы обедающих философов. План простой -- от наивной попытки, т.е. отсутствия синхронизации, до модели акторов. Статья может быть полезна, как введение или для того чтобы освежить свои знания. Автора цель -- разобраться с тем, что интересно здесь.

[TODO Кратко почему это важно. Процессоры достигли лимита физического, лимита внутреннего, но их можно делать больше. Поэтому вопрос важен их взаимодействия эффективного, чтобы вместе они ускоряли работу. Проблема на разных уровнях: на уровне процессора, на уровне процессоров, на уровне машин в сети. ]

(TODO Постараемся еще выделить те решения, которые можно использовать на разных платформах (.Net Core).) 

[TODO Обнови. Сказать что эта модель немного старая. Что конкарренси на сообщениях лучше. И пр.]


# Задача

Эдсгер Дейкстра задавал эту проблему своим ученикам еще в 1965. Устоявшаяся формулировка такая. Есть некоторое (обычно пять) количество философов и столько же вилок. Они сидят за круглым столом, вилки между ними. Философы могут есть из своих тарелок с бесконечной пищей, думать или ждать. Чтобы поесть философу, нужно взять две вилки (последний делит вилку с первым). Взять и положить вилку - два раздельных действия. Все философы безмолвные. Задача найти такой алгоритм, чтобы все они думали и были сыты спустя даже 54 года.


# Вилки на общем столе

Сначала попробуем решить эту задачу через использование разделяемого места. Вилки лежат на общем столе и философы просто их берут, когда они есть и кладут обратно. Здесь появляются проблемы с синхронизацией, когда именно брать вилки? что делать если вилки нет? и др. Но сначала давайте запустим философов.

Для запуска потоков используем пул потоков через Task.Run:

        var cancelTokenSource = new CancellationTokenSource();
        Action<int> create = (i) => RunDeadlock(i, cancelTokenSource.Token);
        for (int i = 0; i < philosophersAmount; i++) 
        {
            int icopy = i;
            // Поместить задачу в очередь пула потоков. Метод RunDeadlock не запускаеться 
            // сразу, а ждет своего потока. Асинхронный запуск.
            philosophers[i] = Task.Run(() => create(icopy), cancelTokenSource.Token);
        }

Пул потоков создан для оптимизации создания и удаления потоков. У этого пула есть очередь с задачами и CLR создает или удаляет потоки в зависимости от количества этих задач. Один пул на все AppDomain'ы. Этот пул стоит использовать почти всегда, т.к. не нужно заморачиваться с созданием, удалением потоков, их очередями и пр. Можно и без пула, но тогда придется напрямую использовать Thread, это целесообразно для случаев, когда нужно поменять приоритет потоку, когда у нас долгая операция, для Foreground потока и др.

CancelationTokenSource здесь нужен, чтобы поток мог сам завершится по сигналу вызывающего потока.

## Блокированные философы

Хорошо, мы умеем создавать потоки, давайте попробуем пообедать:

    // Кто какие вилки взял. К примеру: 1 1 3 3 - 1й и 3й взяли первые две пары.
    private int[] forks = Enumerable.Repeat(0, philosophersAmount).ToArray();

    private void RunDeadlock(int i, CancellationToken token)
    {
        // Ждать вилку, взять её. Эквивалентно: 
        // while(true) 
        //     if forks[fork] == 0 
        //          forks[fork] = i+1
        //          break
        //     Thread.Sleep() или Yield() или SpinWait()
        void TakeFork(int fork) =>
            SpinWait.SpinUntil(() => Interlocked.CompareExchange(ref forks[fork], i+1, 0) == 0);
        void PutFork(int fork) => forks[fork] = 0; // для простоты, но можно с Interlocked.Exchange

        while (true)
        {
            TakeFork(Left(i));
            TakeFork(Right(i));
            eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1);
            PutFork(Left(i));
            PutFork(Right(i));
            Think(i);

            // Завершить работу по-хорошему:
            token.ThrowIfCancellationRequested();
        }
    }

Здесь мы сначала пробуем взять левую, а потом правую вилки и если получилось, то едим и кладем их обратно. Взятие одной вилки атомарно, т.е. два потока не могут взять одну одновременно (неверно: первый читает, что вилка свободна, второй -- тоже, первый берет, второй берет). Для этого Interlocked.CompareExchange, который должен быть реализован с помощью инструкции процессора (TSL, XCHG), которая блокирует участок памяти для атомарного последовательного чтения и записи. А SpinWait эквивалентно конструкции while(true) только с небольшой "магией" -- поток занимает процессор (Thread.SpinWait), но иногда передает управление другому потоку (Thread.Yeild) или засыпает (Thread.Sleep).

Но это решение не работает, т.к. потоки скоро (у меня в течении секунды) блокируются: все философы берут свою левую вилку, а правой нет. Массив forks тогда имеет значения: 1 2 3 4 5. 

[livelock.png]

На рисунке, блокирование потоков (deadlock). Зеленым цветом -- выполнение, красным -- синхронизация, серым -- поток спит. Ромбиками обозначено время запуска Task'ов.


## Голод философов

Хотя чтобы мыслить особенно много еды не нужно, но голод кого угодно заставить бросить философию. Попробуем смоделировать ситуацию голодания потоков в нашей задаче. Голодание -- это когда поток работает, но без существенной работы, другими словами это тот же дедлок, только теперь поток не спит, а активно ищет как бы поесть, но еды нет. Для того, чтобы избежать частую блокировку будем класть вилку назад, если не смогли взять другую.

    // Тоже что и в RunDeadlock, но теперь кладем вилку назад и добавляем плохих философов
    private void RunStarvation(int i, CancellationToken token)
    {
        while (true)
        {
            bool hasTwoForks = false;
            var waitTime = TimeSpan.FromMilliseconds(50);
            // плохой философов может уже иметь вилку:
            bool hasLeft = forks[Left(i)] == i + 1;
            if (hasLeft || TakeFork(Left(i), i + 1, waitTime))
            {
                if (TakeFork(Right(i), i + 1, TimeSpan.Zero))
                    hasTwoForks = true;
                else
                    PutFork(Left(i)); // иногда плохой философ отдает вилку назад
            } 
            if (!hasTwoForks)
            {
                if (token.IsCancellationRequested) break;
                continue;
            }
            eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1);
            bool goodPhilosopher = i % 2 == 0;
            // А плохой философ забывает положить свою вилку обратно:
            if (goodPhilosopher)
                PutFork(Left(i));
            PutFork(Right(i)); // А если и правую не положит, то хорошие будут вообще без еды.

            Think(i);

            if (token.IsCancellationRequested)
                break;
        }
    }

    // Теперь можно ждать определенное время
    bool TakeFork(int fork, int philosopher, TimeSpan? waitTime = null)
    {
        return SpinWait.SpinUntil(() => Interlocked.CompareExchange(ref forks[fork], philosopher, 0) == 0,
                                  waitTime ?? TimeSpan.FromMilliseconds(-1));
    }

В этом коде важно то, что два из четырех философа забывают положить свою левую вилку. И получается, что они едят больше еды, а другие начинают голодать, хотя у потоков одинаковый приоритет. Здесь они не совсем голодают, т.к. плохие философы кладут свои вилки иногда назад. У меня получаеться, что хорошие едят где-то в 5 раз меньше, чем плохие. Так небольшая ошибка в коде приводит к тому, что падает производительность. Здесь еще стоит заметить, что возможна редкая ситуация, когда все философы берут левую вилку, правой нет, они кладут левую, ждут, опять берут левую и т.д. Эта ситуация тоже голодание, больше похожая на взаимную блокировку. Повторить ее у меня не получилось. Ниже картика для ситуации, когда два плохих философа забрали обе вилки, а два хороших голодают.

[Starvation ] 

Здесь видно, что потоки просыпаются иногда и пробуют получить ресурс. Два ядра из четырех ничего не делают (зеленый график вверху). 

## Смерть философа

Ну и еще одна проблема, которая может прервать славный обед философов -- это если один из них внезапно умрёт с вилками в руках (и его так и похоронят). Тогда соседи остануться без обеда. Пример кода для этого случая вы можете придумать и сами, например выбрасывается NullReferenceException после того, как философ берет вилки. И, между прочим, исключение будет не обработанным и вызывающий код его просто так не поймает (для этого AppDomain.CurrentDomain.UnhandledException и др.). Поэтому обработчики ошибок необходимы в самих потоках и с корректным завершением.

## Официант

Хорошо, как нам решить эту проблему с взаимными блокировками, голоданием и смертями? Будем допускать только одного философа до вилок, добавим взаимное исключение (mutual exclusion) потоков для этого места. Как это сделать? Предположим, что рядом с философами стоит официант, который дает разрешение какому-нибудь одному философу взять вилки. Как нам сделать этого официанта и как философы будут просить его, вопросы интересные. 

Простейший способ -- это когда философы будут просто постоянно просить официанта дать доступ к вилкам. Т.е. теперь философы будут не ждать вилку рядом, а ждать или просить официанта. Сначала исользуем для этого только User Space, в нем мы не используем прерывания для вызова каких-нибудь процедур из ядра (о них ниже).

## Решения в пространстве пользователя

Здесь будем делать тоже, что раньше делали с одной вилкой и двумя философами, будем крутиться в цикле и ждать. Но теперь это будут все философы и как бы только одна вилка, т.е. можно сказать будет есть только тот философ, который взял эту "золотую вилку" у официанта. Для этого используем SpinLock.

    private static SpinLock spinLock = new SpinLock();  // это наш "официант"
    private void RunSpinLock(int i, CancellationToken token)
    {
        while (true)
        {
            bool hasLock = false;
            try
            {
                spinLock.Enter(ref hasLock);  // взаимная блокировка через busy waiting
                // здесь может быть только один поток (mutual exclusion)
                forks[Left(i)] = i + 1;  // Берем вилку сразу, без ожидания
                forks[Right(i)] = i + 1;
                eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1);
                forks[Left(i)] = 0;
                forks[Right(i)] = 0;
            }
            finally
            {
                if(hasLock) spinLock.Exit();  // избегаем проблемы со смертью философа
            }

            Think(i);

            if (token.IsCancellationRequested)
                break;
        }
    }

SpinLock это блокировщик, с, грубо говоря, тем же while(true) { if (!lock) break; }, но с еще большей "магией", чем в SpinWait (который там используется). Теперь он умеет считать ожидающих, немного усыплять их и мн. др. В общем, делает всё возможное для оптимизации. Но надо помнить, что это всё тот же активный цикл, который ест ресурсы процессора и держит поток, который может привести к голоданию, если один из философов становиться приоритетнее других, но не имеет золотой вилки (Priority Inversion problem). Поэтому используем его только для очень очень коротких изменений в общей памяти, без всяких сторонних вызовов, вложенных блокировок и пр. сюрпризов.

[SpinLock]

Рисунок для SpinLock. Потоки постоянно "воюют" за золотую вилку. Случаются провалы -- на рисунке выделенная область. Ядра используются не полностью: только около 2/3 этими четырьмя потоками.

Другое решение здесь было бы использовать только Interlocked.CompareExchange с тем же активным ожиданием, как показано в коде выше (в голодающих философах), но это, как было уже сказано, теоретически может привести к блокировке. Код доступен в проекте к этой статье на Гитхабе (RunInterlocked).

Про Interlocked стоит сказать, что там не только CompareExchange, но и другие методы для атомарного чтения И записи. А через повтор изменения в случае, если другой поток успевает внести свои изменения (чтение 1, чтение 2, запись 2, запись 1 плохая), он может использоваться для сложных изменений одного значения (Interlocked Anything паттерн).

# Решения в режиме ядра

Чтобы избежать потери ресурсов в цикле, посмотрим как можно блокировать поток. Другими словами, продолжая наш пример, посмотрим, как официант усыпит философа и разбудит его только тогда, когда надо. Сначала рассмотрим, как это сделать через режим ядра операционной системы. Все структуры там часто оказываются медленнее, чем те, что в пространстве пользователя. Медленее в несколько раз, например AutoResetEvent может быть в 53 раза медленнее SpinLock [Рихтер]. Но с их помощью можно синхронизировать процессы по всей системе, управляемые или нет.

Основная конструкция здесь это семафор, предложенный Дейкстрой более полувека назад. Семафор это, упрощенно говоря, это положительное целое число, управляемое системой, и две операции на нем, -- увеличить и уменьшить. Если уменьшить не получается, ноль, то вызывающий поток блокируется. Когда число увеличивается каким-нибудь другим активным потоком/процессом, тогда потоки пропускаются, а семафор опять уменьшается на число прошедших. Можно представить поезда в узком месте с семафором. .NET предлагает несколько конструкций с подобными функциями: AutoResetEvent, ManualResetEvent, Mutex и сам Semaphore. Мы будем использовать AutoResetEvent, это самая простая из этих конструкций: только два значения 0 и 1 (false, true). Ее метод WaitOne() блокирует вызывающий поток, если значение было 0, а если 1, то понижает до 0 и пропускает его. А метод Set() повышает до 1 и пропускает одного ожидающего, который опять понижает до 0. Действует, как турникет в метро.

Теперь усложним решение и будем использовать блокировку для каждого философа, а не для всех сразу. Т.е. теперь есть могут сразу несколько философов, а не один. Но мы опять блокируем доступ к столу, для того чтобы корректно, избегая гонок (race conditions), взять вилки. 


    // Для блокирования отдельного философа.
    // Инициализируется: new AutoResetEvent(true) для каждого
    private AutoResetEvent[] philosopherEvents;  

    // Для доступа к вилкам / доступ к столу
    private AutoResetEvent tableEvent = new AutoResetEvent(true);

    // Рождение философа
    public void Run(int i, CancellationToken token)
    {
        while (true)
        {
            TakeForks(i); // Ждет вилки
            // Обед. Может быть и дольше
            eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1);
            PutForks(i); // Отдать вилки и разблокировать соседей
            Think(i);
            if (token.IsCancellationRequested) break;
        }
    }

    // Ожидать вилки в блокировке
    void TakeForks(int i)
    {
        bool hasForks = false;
        while (!hasForks) // Попробовать еще раз (блокировка не здесь)
        {
            // Исключающий доступ к столу, без гонок за вилками
            tableEvent.WaitOne();
            if (forks[Left(i)] == 0 && forks[Right(i)] == 0)
                forks[Left(i)] = forks[Right(i)] = i + 1;
            hasForks = forks[Left(i)] == i + 1 && forks[Right(i)] == i + 1;
            if (hasForks)
                // Теперь философ поест, выйдет из цикла. Если Set 
                // вызван дважды, то значение true.
                philosopherEvents[i].Set();
            // Разблокировать одного ожидающего. После него 
            // значение tableEvent в false.
            tableEvent.Set(); 
            // Если имеет true, не блокируется,
            // а если false, то будет ждать Set от соседа.
            philosopherEvents[i].WaitOne();
        }
    }

    // Отдать вилки и разблокировать соседей
    void PutForks(int i)
    {
        tableEvent.WaitOne(); // без гонок за вилками
        forks[Left(i)] = 0;
        // Пробудить левого, а потом и правого соседа,
        // либо AutoResetEvent в true
        philosopherEvents[LeftPhilosopher(i)].Set();
        forks[Right(i)] = 0;
        philosopherEvents[RightPhilosopher(i)].Set();
        tableEvent.Set();
    }

Чтобы понять, что тут происходит, рассмотрим случай, когда философу не удалось взять вилки, тогда его действия будут такими. Он ждет доступа к столу. Получив его он пробует взять вилки. Не получилось. Он отдает доступ к столу (взаимное исключение). И проходит свой "турникет" (AutoResetEvent) (вначале они открыты). Попадает опять в цикл, т.к. у него нет вилок. Пробует взять их и останавливается у своего "турникета". Какой-нибудь более удачливый сосед справа или слева, закончив есть, разблокирует нашего философа, "открывая его турникет". Наш философ проходит его (и он закрывается за ним) во второй раз. Пробует в третий раз взять вилки. Удачно. И проходит свой турникет, чтобы отобедать.

Когда в таком коде будут случайные ошибки (они всегда есть), например будет неверно указан сосед или создан один и тот же объект AutoResetEvent для всех (Enumerable.Repeat), тогда философы будут ждать уже разработчиков, т.к. поиск ошибок в таком коде довольно сложное занятие. 

## Гибридные решения
 
# Сообщения и распределенные системы

[Designing Data-Intensive Applications:
When writing multi-threaded code on a single machine, we have fairly good tools for making it thread-safe: mutexes, semaphores, atomic counters, lock-free data structures, blocking queues, and so on. Unfortunately, these tools don’t directly translate to distributed systems, because a distributed system has no shared memory—only messages sent over an unreliable network.]


# Источники

[Рихтер ] 

